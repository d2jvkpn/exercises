### Title
---

#### chapter 3
1. Event queues based on the technology we discuss in this chapter is used in many popular libraries
 like:
- mio (https://github.com/tokio-rs/mio), a key part of popular runtimes like Tokio
- polling (https://github.com/smol-rs/polling), the event queue used in Smol
and async-std
- libuv (https://libuv.org/), the library used to create the event queue used in Node.js
(a JavaScript runtime) and the Julia programming language
- C# for its asynchronous network calls
- Boost.Asio, a library for asynchronous network I/O for C++

2. Readiness-based event queues: epoll and kqueue
2.1 We create an event queue by calling the syscall epoll_create or kqueue.
2.2 We ask the OS for a file descriptor representing a network socket.
2.3 Through another syscall, we register an interest in Read events on this socket. It’s important
that we also inform the OS that we’ll be expecting to receive a notification when the event is
ready in the event queue we created in step 1.
2.4 Next, we call epoll_wait or kevent to wait for an event. This will block (suspend) the
thread it’s called on.
2.5 When the event is ready, our thread is unblocked (resumed) and we return from our wait
call with data about the event that occurred.

3. Completion-based event queues
3.1 We create an event queue by calling the syscall CreateIoCompletionPort.
3.2 We create a buffer and ask the OS to give us a handle to a socket.
3.3 We register an interest in Read events on this socket with another syscall, but this time we
also pass in the buffer we created in (step 2) , which the data will be read to.
3.4 Next, we call GetQueuedCompletionStatusEx, which will block until an event has
been completed.
